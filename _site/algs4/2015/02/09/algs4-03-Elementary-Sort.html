<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>algorithms03-Elementary-Sort</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="/algs4/2015/02/09/algs4-03-Elementary-Sort.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/"></a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">algorithms03-Elementary-Sort</h1>
    <p class="post-meta">Feb 9, 2015</p>
  </header>

  <article class="post-content">
    <p>这一讲的内容是几个基础的排序方法，选择排序，插入排序，希尔排序以及之前提到过的Knuth Shuffle。基本都是学过的内容，复习巩固一下，这篇博文主要总结java中Comparable接口的应用以及希尔排序。</p>

<h3 id="comparable">Comparable接口</h3>

<p>在程序设计中，<strong>回调(Callback)</strong>是一个很有用的概念，它指的是“对一段可执行代码的引用”，通俗地讲，一个用户程序client调用了服务程序中的某个方法，这个方法又<em>回过头调用client的一个<strong>函数</strong></em>，这就被称为回调。比较常见的例子就是排序函数了，例如使用C的qsort函数时，要以函数指针的方法传给它一个比较函数，换个角度看，这不就正是qsort函数“回过头来调用”了我们自定义的比较函数吗，这就是所谓回调。</p>

<p>各种语言实现回调的方式有所差异，如上文提到的，C是用函数指针实现回调的。而在java中，我们<strong>使用接口来实现回调</strong>。还是以排序函数（称为sort）为例，sort所接受的参数（一般是要排序的数列）实现Comparable接口，这样sort就可以反过来调用参数的cmpareTo函数，进行比较，实现了回调。来看具体的代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">String</span> <span class="n">str</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Item</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">str</span> <span class="o">=</span> <span class="n">str</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Item</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// TODO Auto-generated method stub</span>
		<span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">i</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="na">i</span><span class="o">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">i</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">.</span><span class="na">i</span><span class="o">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>其中Comparable采用泛型的目的是指明比较函数接受的参数（即Comparable<item>尖括号中的类型与compareTo(Item o)函数接受的参数类型必须是一样的。具体进行回调的代码（即sort函数）见下面的的实例代码。</item></p>

<h3 id="selectionsort">选择排序（SelectionSort）</h3>

<p>选择排序应该是最简单的排序了吧，不过还是有可以总结的地方的。先上代码，方便分析：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">SelectionSort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">min</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>
	<span class="o">}</span>
			
<span class="o">}</span></code></pre></div>

<p>我们从<strong>不变性(invariants)</strong>的角度进行分析，选择排序算法执行过程中保持的不变性是：扫描过的部分（具体到代码中就是０到ｉ的部分）始终是递增的，并且没有扫描过的部分所有的数都比扫描过的部分的数大（这与下面要说的插入排序不同）。选择排序的原理就是不断重复这样的过程（每次选出未扫描过的最小数，与ｉ进行交换）直到最后全部的数组都扫描过，所有都是有序的。</p>

<p>一次完整的选择排序共需~<script type="math/tex">N^2/2</script>次比较操作和N次交换操作，时间复杂度为~<script type="math/tex">N^2</script>，<strong>注意，不管是序列的情况如何，即使是已经有序的序列，复杂度仍然是~<script type="math/tex">N^2</script>，这与插入排序不同</strong></p>

<h3 id="insertsort">插入排序（InsertSort）</h3>

<p>同样是先上代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">InsertSort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
				<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
			<span class="k">else</span> 
				<span class="k">break</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>插入排序维护的不变性是：ｉ左边的所有元素均为递增。即只有选择排序维护的不变性的第一部分，<strong>它不保证在ｉ左边的元素一定比右边小</strong>。我想这也是插入排序不是每种情况都有~<script type="math/tex">N^2</script>的复杂度的原因。</p>

<p>平均来说，对于一个顺序为随机的序列，插入排序需要~<script type="math/tex">N^2/4</script>次比较和~<script type="math/tex">N^2/4</script>次交换（最差情况将两个４改成２），表面上看，插入排序凭空比选择排序多出了那么多的交换操作，而涉及访存的操作操作又是最耗时的，那么插入排序一定比选择排序慢得多了？其实不然，<strong>在序列基本有序（“逆序数”为c*N这个级别，ｃ为常数）时，插入排序可以在线性时间内完成！</strong>，实际上，可以证明，<strong>插入排序的交换操作数等于序列的逆序数（比较数等于交换数＋Ｎ－１）</strong>。</p>

<p>这是个很重要的结论，这表明在序列基本有序的时候插入排序是十分快的，而实际上我们经常碰到这样“基本有序”的数列。不仅如此，我们还可以主动去“制造”这样基本有序的序列，为高效的插入排序创造条件，这是我们的第一个想法；除此之外，插入排序一个一个地交换太浪费时间，能否跨步走呢？这是我们的第二个想法。一个快得多的排序方式：希尔排序，正是基于这两个很自然的想法。</p>

<h3 id="shellsort">希尔排序（ShellSort）</h3>

<p>希尔排序相较于前两个方法要复杂一些，它是先对序列进行若干次h-sort，即跨度为ｈ的插入排序，通过这种方式来将数组变得“基本有序”。注意，这里的ｈ是越来越小的，到最后变成1-sort，就是我们的插入排序，然而这时的序列以及很“有序”了，插入排序进行得非常快。可以想见，希尔排序整体速度是很快的，因为对于前面ｈ比较大的插入排序，实际上进行操作的数组只有N/h（不要看到这里认为“这不还是没什么改变吗，ｈ是常数啊”，注意ｈ不是常数，刚开始的ｈ是很大的，一般至少N/3）,而对于后面ｈ较小的，注意此时序列已经基本有序了。</p>

<p>ｈ的序列一般采用Knuth的3x+1序列，即1,4,13,40,121,364…，这时的希尔排序在最差情况下的时间复杂度是Ｏ（<script type="math/tex">N^{3/2}</script>），而在平均情况下，它的时间复杂度只有大约nlog(n)，精确的表述仍未被发现。</p>

<p>下面是希尔排序的代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span><span class="o">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">h</span><span class="o">)</span>
				<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="n">h</span><span class="o">);</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
