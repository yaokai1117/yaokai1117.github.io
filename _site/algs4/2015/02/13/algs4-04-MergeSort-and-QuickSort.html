<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="/css/main.css">
	<title>algorithms04-MergeSort-and-QuickSort</title>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
                  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
                          });
	</script>
	<script type="text/javascript"
  	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
</head>

<body id="bkg">

<div id="wrapper">

	<div id="header">
		<h1>Enjoy learning, enjoy coding</h1>
	</div>

	<div id="menu">
		<ul>
			<li><a href="/index.html">Home</a></li>
			<li><a href="/post_lists/total_list.html">Posts</a></li>
			<li><a href="http://home.ustc.edu.cn/~yaokai">About Me</a></li>
			<li><a href="https://github.com/yaokai1117">GitHub</a></li>
		</ul>
	</div>

	<div id="content">
		<hr />
		<div id="post">

  <div class="" ="post-header">
    <h1 class="post-title">algorithms04-MergeSort-and-QuickSort</h1>
    <p class="post-meta">Feb 13, 2015</p>
  </div>

  <div class="post-content">
    <p>这周课程的内容是两个应用非常广的排序算法:MergeSort和QuickSort,相较于上一篇博文中提到的算法，这两个算法的速度要快得多（非平凡算法），我很担心一篇博文的篇幅能否叙述完，let’s have a look.</p>

<h3 id="comparator">Comparator的使用</h3>

<p>在上一篇博文中我们简单总结了一下Comparable接口的用法，这一次是Comparator，虽然看起来很像，但是两者有很大的区别。Comparator与Ｃ中函数指针的用法更接近了，不过它是直接传一个对象过去，可以将Comparator理解为“一种比较的方法”（与之对应的，Comparable更像是赋予实现对象一个“可以进行比较的属性”），使用Comparator可以以多种顺序进行比较，只要对应地实现多个Comparator对象即可，一般某个对象的某一个Comparator用大写字母命名（见下，public static final嘛）。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">BY_ID</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ById</span><span class="o">();</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">BY_NAME</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ByName</span><span class="o">();</span>
	
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Student</span> <span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="cm">/**/</span><span class="o">}</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ById</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Student</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Student</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">id</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ByName</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="o">{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Student</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Student</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">o1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h3 id="mergesort">归并排序（MergeSort）</h3>

<p>归并排序是分治法的一个典型应用。假设我们有两个已经排好序的数列，要将它们合并为一个有序数列，那么线性时间的算法是显然的，“两个指针，一趟扫描”。归并排序的实现就是基于此，我们将要排序的数列分成两半，递归地分别对这两个子数列进行排序，然后进行归并。来看代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CUTOFF</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">aux</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
			<span class="n">aux</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
		
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">low</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">;</span> <span class="n">k</span><span class="o">++){</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span>
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">high</span><span class="o">)</span>
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
			<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
			<span class="k">else</span> 
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">aux</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
		
<span class="c1">//		if(low &gt;= high)</span>
<span class="c1">//			return;</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">high</span> <span class="o">&lt;=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">CUTOFF</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>			<span class="c1">// First step of optimizing, using insertion sort for tiny subarrays</span>
			<span class="n">InsertSort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
		<span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
		<span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">mid</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>	<span class="c1">// Second step of optimizing, stopped</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>对长度为Ｎ的序列进行归并排序需要进行NlogN次比较操作和6NlogN次数组访问操作，因此有NlogN的时间复杂度，比上篇博文中的算法要快了很多。空间使用方面，归并排序需要cN的额外内存空间（也有in-place的算法，但因为太复杂而不实用）。值得注意的是，（未经优化的）归并排序<strong>在所有情况下的复杂度都是NlogN</strong>,这与快排有很大不同。它与快排的另外一点区别是，归并排序是稳定的，而快排不是（顺带一提上篇博文中三种算法中只有插入排序是稳定的）。</p>

<p>归并排序可以进行一些优化。首先，当子数列较小时，使用归并排序有点大材小用了，并不合算，所以当要处理的数组长度小于等于７时，改用插入排序是一个不错的做法（见代码中注释Step1处），当然，直接无视这一类情况，最后整体来一遍插入排序也是很好的做法；然后，考虑到归并排序处理已经排好了的序列也需要NlogN的时间，我们可以避免这一情况，见Step2处，如果判断出两个分数组已经排好序了，就不进行归并了。</p>

<p>归并排序有另一种被称为bottom-up的实现方法，代码简洁且不需要递归（然而在许多情况下比原来的实现方式稍稍慢一点），它是先从跨度为一归并起，然后跨度为２,以此类推。代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sortBU</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
	<span class="n">Object</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">N</span><span class="o">];</span> 
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="o">)</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">-</span><span class="n">size</span><span class="o">;</span> <span class="n">low</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="o">)</span>
			<span class="n">merge</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">aux</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">low</span><span class="o">+</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">low</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">),</span> <span class="n">c</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>

<p>利用归并排序可以实现计算一个数列的逆序数的NlogN算法，一边归并，一边计数，每个“排在后面”的元素的并入都带来mid-i+1的逆序数增加。</p>

<h4 id="quicksort">快速排序（QuickSort）</h4>

<p>接下来就是大名鼎鼎的快排了，这是应用及其广泛的算法，快如其名。快排同样是基于分治法，与归并不同，快排是先处理再递归，首先选一个数组元素作为枢轴，然后通过分划使比这个元素大的都移到它右边，比它小的都移到右边。然后递归对左右两个数列进行操作，最终完成对整个数组的排序。代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[++</span><span class="n">i</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">low</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">high</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[--</span><span class="n">j</span><span class="o">],</span> <span class="n">a</span><span class="o">[</span><span class="n">low</span><span class="o">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">low</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">)</span>
			<span class="k">break</span><span class="o">;</span>
		<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
	<span class="k">return</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
	
<span class="c1">//		if (low &gt;= high)</span>
<span class="c1">//			return;</span>
	
	<span class="k">if</span> <span class="o">(</span><span class="n">high</span> <span class="o">&lt;=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">CUTOFF</span> <span class="o">-</span> <span class="mi">1</span><span class="o">){</span>								<span class="c1">//using insertion sort for tiny subarrays</span>
		<span class="n">InsertSort</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
		<span class="k">return</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)((</span><span class="n">high</span><span class="o">-</span><span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)*</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">())</span> <span class="o">+</span> <span class="n">low</span><span class="o">;</span>		<span class="c1">//random pivot, avoid &quot;the worst condition&quot;</span>
	<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pivot</span><span class="o">);</span>
	
	<span class="n">pivot</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
	<span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pivot</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
	<span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>

<p>快排的平均时间复杂度也是NlogN，只需要常数的额外空间，是in-place算法，而且要比归并快一些。简单分析一下，每次对整个数组进行分划（由若干个小分划组成）需要线性时间，而平均情况下这样的操作一共要有logN次，所以复杂度是NlogN。</p>

<p>然而通常的以第一个元素为枢轴的快排有一个很致命的缺点：当待排序的数组已经有序或者逆序的时候，会退化为冒泡排序，复杂度一下子变为<script type="math/tex">N^2</script>,这是因为这种情况下每次分划只向前进一位，需要1+2+3+…+(n-1)+n~<script type="math/tex">\frac{1}{2}n^2</script>次比较。解决这个问题有几种可行的思路，一个是快排前将数组shuffle一次，这是教程中的做法；另一种是去一个０～Ｎ的随机数，将其与第一个调换，然后在快排，这是很常用的随机化快排，也是这篇博文中代码所用的方法；第三种是取第一个、最后一个和中位数三个数字，然后再中间大小的数。</p>

<p>这三种方法可以避免（极大地减小几率）worst case的出现，然而，当数组中有大量相同键时，它们还是无能为力，复杂度还是会跌到<script type="math/tex">N^2</script>。这时我们就需要快排的一个变种：三路分划快排。即将数组分划为三个部分，小于ｖ的，等于ｖ的，和大于ｖ的。我们使用lt,i和gt三个变量，算法执行过程中维持的不变性是：lt左边的都小于ｖ，gt右边的都大于ｖ，从lt到i-1都是等于ｖ的，最终退出循环时有gt==v-1，这时lt和gt就将数组分成了我们想要的三个部分了。另外，这种方法实现的快排代码意外地简洁，且不需递归，来看代码：</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort3Way</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="n">Comparator</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>	
	<span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&gt;=</span> <span class="n">high</span><span class="o">)</span>
		<span class="k">return</span><span class="o">;</span>
	
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">low</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">high</span><span class="o">;</span>
	<span class="n">Object</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">low</span><span class="o">];</span>
	<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">){</span>
		<span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">v</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
			<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">++,</span> <span class="n">lt</span><span class="o">++);</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
			<span class="n">swap</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
		<span class="k">else</span> 
			<span class="n">i</span><span class="o">++;</span>
	<span class="o">}</span>
	
	<span class="n">sort3Way</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
	<span class="n">sort3Way</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">high</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>


  </div>

</div>

		<hr />
	</div>	

</div>

</body>
</html>